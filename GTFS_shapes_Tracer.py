# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GTFSshapesTracer
                                 A QGIS plugin
 It transforms the Public Transport paths in GTFS Shapes.txt
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-12-06
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Luigi
        email                : luigi.dalbosco@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QListWidgetItem
from qgis.core import QgsProject, QgsVectorLayer, QgsRasterLayer
from PyQt5.QtWidgets import QMessageBox

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .GTFS_shapes_Tracer_dialog import GTFSshapesTracerDialog
import os.path
import pandas as pd

# import functions from core_function.py
from .core_functions import (shape_txt, 
                             save_and_stop_editing_layers, 
                             stop_times_update,
                             if_display,
                             shp_dst_trvl,
                             if_remove
)

class GTFSshapesTracer:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor."""

        self.GTFSshapesTracer_dialog = GTFSshapesTracerDialog()

        """
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GTFSshapesTracer_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GTFS shapes Tracer')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GTFSshapesTracer', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/GTFS_shapes_Tracer/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'3. GTFS shapes Tracer'),
            callback=self.run,
            parent=self.iface.mainWindow())

        self.GTFSshapesTracer_dialog.LoadTripButton.clicked.connect(self.__updateTrips)

        self.GTFSshapesTracer_dialog.DiplayTripsButton.clicked.connect(self.__displayTrips)

        self.GTFSshapesTracer_dialog.LoadBKgroundMapsButton.clicked.connect(self.__displayOSMCHIMG)

        # will be set False in run()
        self.first_start = True

    def __updateTrips(self):
        self.GTFSshapesTracer_dialog.tripsListWidget.clear()  # Clear existing items
        outputspath = self.GTFSshapesTracer_dialog.OutPutQgsFolderWidget.filePath()
        ls_files = os.listdir(outputspath)
        ls_trip_all = [file for file in ls_files if str(file[-5:]) == ".gpkg"]
        ls_trips_to_display = [file for file in ls_trip_all if file != 'OSM4routing.gpkg' and file != 'mini_shapes.gpkg']
    
        for trip_to_disp in ls_trips_to_display:
            self.GTFSshapesTracer_dialog.tripsListWidget.addItem(QListWidgetItem(str(trip_to_disp)))
    
    def __displayTrips(self):
        outputspath = self.GTFSshapesTracer_dialog.OutPutQgsFolderWidget.filePath()

        selected_items = self.GTFSshapesTracer_dialog.tripsListWidget.selectedItems()
        ls_to_disp = [item.text() for item in selected_items]

        for trip in ls_to_disp:
            if not QgsProject.instance().mapLayersByName(str(trip[:-5])):
                trip_gpkg = str(outputspath)+'/'+str(trip)
                tirp_layer = QgsVectorLayer(trip_gpkg,str(trip[:-5]),"ogr")
                QgsProject.instance().addMapLayer(tirp_layer)

    def __displayOSMCHIMG(self):

        dwnldfld = self.GTFSshapesTracer_dialog.DownloadQgsFolderWidget.filePath()

        city_roads_name = 'OSM_roads'

        temp_folder = 'OSM_data'
        road_temp_folder = os.path.join(dwnldfld,temp_folder)

        city_roads_name = 'city roads'
        city_rails_name = 'city rails'
        city_Regtrain_name = 'city Regtrain'
        city_funicular_name = 'city funicular'

        OSM_roads_name = 'OSM_roads'
        OSM_roads_gpkg = str(road_temp_folder)+'/'+str(OSM_roads_name)+'.gpkg'

        OSM_tram_name = 'OSM_tram'
        OSM_rails_gpkg = str(road_temp_folder)+'/'+str(OSM_tram_name)+'.gpkg'

        OSM_Regtrain_name = 'OSM_Regtrain'
        OSM_Regtrain_gpkg = str(road_temp_folder)+'/'+str(OSM_Regtrain_name)+'.gpkg'

        OSM_funicular_name = 'OSM_funicular'
        OSM_funicular_gpkg = str(road_temp_folder)+'/'+str(OSM_funicular_name)+'.gpkg'

        # publishing the back ground for better read of the data
        if not QgsProject.instance().mapLayersByName('SWISSIMAGE 10 cm'):
            uri = "contextualWMSLegend=0&crs=EPSG:4326&dpiMode=7&featureCount=10&format=image/jpeg&layers=ch.swisstopo.swissimage&styles=default&tilePixelRatio=0&url=https://wms.geo.admin.ch/"
            CHimage_layer = QgsRasterLayer(uri, "SWISSIMAGE 10 cm", 'wms')
            QgsProject.instance().addMapLayer(CHimage_layer)

        if not QgsProject.instance().mapLayersByName('OSM Standard'):
            uri = "type=xyz&zmin=0&zmax=19&url=http://tile.openstreetmap.org/{z}/{x}/{y}.png"
            OSMmap_layer = QgsRasterLayer(uri, "OSM Standard", 'wms')
            QgsProject.instance().addMapLayer(OSMmap_layer)

        if not QgsProject.instance().mapLayersByName(city_roads_name):
            city_roads_layer = QgsVectorLayer(OSM_roads_gpkg,city_roads_name,"ogr")
            QgsProject.instance().addMapLayer(city_roads_layer)

        if_display(OSM_rails_gpkg,city_rails_name)

        if_display(OSM_Regtrain_gpkg,city_Regtrain_name)

        if_display(OSM_funicular_gpkg,city_funicular_name)


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GTFS shapes Tracer'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            

        # show the dialog
        self.GTFSshapesTracer_dialog.show()
        # Run the dialog event loop
        result = self.GTFSshapesTracer_dialog.exec_()
        # See if OK was pressed

        dwnldfld = self.GTFSshapesTracer_dialog.DownloadQgsFolderWidget.filePath()

        outputspath = self.GTFSshapesTracer_dialog.OutPutQgsFolderWidget.filePath()
	
        if result:
            
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            # setting message for Message Box
            msg.setText("The \'GTFS shapes Tracer\' is in progress wait until the message box is closed")
            # setting Message box window title
            msg.setWindowTitle("!! wait the next message \'GTFS shapes Tracer\' is in progress !!")
            msg.show()
            
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            all_layers = QgsProject.instance().mapLayers().values()  # Get all layers in the project
            save_and_stop_editing_layers(all_layers)



            name_folder = 'shapes'
            shape_folder = os.path.join(outputspath,name_folder)

            tempfolder = 'temp/lines_trips'
            temp_folder_linestrip= os.path.join (dwnldfld,tempfolder)

            tempfolder = 'temp/stop_times_perroute'
            temp_folder_Ttbls_per_route= os.path.join (dwnldfld,tempfolder)

            shapes_txt = os.path.join(dwnldfld,'shapes.txt')
            
            Ttlbs_txt = str(dwnldfld)+'/stop_times.txt'
            
            temp_folder = 'OSM_data'
            road_temp_folder = os.path.join(dwnldfld,temp_folder)
            OSM_roads_name = 'OSM_roads'
            OSM_roads_gpkg = str(road_temp_folder)+'/'+str(OSM_roads_name)+'.gpkg'

            lines_df_csv = str(dwnldfld)+'/lines_files_list.csv'

            lines_trips_csv =  str(dwnldfld)+'/lines_trips.csv'

            # loading the trips in gpkg 
            ls_files = os.listdir(outputspath)
            ls_trip_all = [file for file in ls_files if str(file[-5:]) == ".gpkg"]
            ls_trip_to_shape = [file for file in ls_trip_all if file != 'OSM4routing.gpkg' and file != 'mini_shapes.gpkg']

            for trip_to_shape in ls_trip_to_shape:
                trip_gpkg = os.path.join(outputspath,trip_to_shape)
                trip_name = str(trip_to_shape[:-5])
                shp_dst_trvl(lines_trips_csv,trip_gpkg,trip_name)
            
            Ttbls = pd.read_csv(Ttlbs_txt,dtype='str')

            if 'shape_dist_traveled' in Ttbls.columns:
                Ttbls = Ttbls.drop(['shape_dist_traveled'],axis=1)
                os.remove(Ttlbs_txt)
                Ttbls.to_csv(Ttlbs_txt,index=False)

            Ttbls_with_seq = pd.DataFrame()

            shapes = pd.DataFrame()

            for trip_to_shape in ls_trip_to_shape:
                trip_gpkg = os.path.join(outputspath,trip_to_shape)
                trip_name = str(trip_to_shape[:-5])
                trip_vertex_gpkg = str(temp_folder_linestrip)+'/'+str(trip_name)+'_vertex.gpkg'
                shape_csv = os.path.join(shape_folder,str(trip_name)+'.csv')
                trip = shape_txt(trip_gpkg,trip_name,shape_csv,trip_vertex_gpkg)
                Ttbl_with_seq = stop_times_update(trip_name, lines_df_csv, lines_trips_csv, OSM_roads_gpkg, temp_folder_linestrip, trip_gpkg)
                Ttbls_with_seq = pd.concat([Ttbls_with_seq, Ttbl_with_seq])
                shapes = pd.concat([shapes,trip],ignore_index=True)

            shapes = shapes.rename(columns = {'fid':'shape_pt_sequence','line_trip':'shape_id','lon':'shape_pt_lon','lat':'shape_pt_lat'})
            if_remove(shapes_txt)

            shapes.to_csv(shapes_txt,index=False)


            Ttbls = pd.read_csv(Ttlbs_txt)
            Ttbls_to_merge = Ttbls_with_seq[['orig_id','shape_dist_traveled']]
            Ttbls = Ttbls.merge(Ttbls_to_merge, how='left', on='orig_id')

            os.remove(Ttlbs_txt)
            Ttbls.to_csv(Ttlbs_txt,index=False)

            import zipfile

            trips_txt = str(dwnldfld)+'/trips.txt'
            routes_txt = str(dwnldfld)+'/routes.txt'
            agency_txt = str(dwnldfld)+'/agency.txt'
            stops_txt = str(dwnldfld)+'/stops.txt'
            calendar_txt = str(dwnldfld)+'/calendar.txt'
            calendar_dates_txt = str(dwnldfld)+'/calendar_dates.txt'
            zip_file = str(dwnldfld)+'/'+os.path.splitext(os.path.basename(dwnldfld))[0]+'.zip'
            lista_files = [Ttlbs_txt,shapes_txt ,trips_txt,routes_txt,agency_txt,stops_txt,calendar_txt,calendar_dates_txt]
            with zipfile.ZipFile(zip_file, 'w') as zipMe:
                for file in lista_files:
                    zipMe.write(file, arcname=os.path.basename(file), compress_type=zipfile.ZIP_DEFLATED)

            print('shapes.txt is ready!')

            msg.close()

            msg2 = QMessageBox()
            msg2.setIcon(QMessageBox.Information)
            msg2.setText("Find the zip GTFS file with all the shapes you created \nin the zip file: " + str(zip_file))
            msg2.setWindowTitle("Done !")
            msg2.exec_()